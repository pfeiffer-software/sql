<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JOIN-Simulation (manuell)</title>
  <style>
    :root{
  --border:#1f1f1f;
  --soft:#eaeaea;
  --card:#ffffff;
  --shadow: 0 6px 18px rgba(0,0,0,.06);
  --radius: 14px;
}

/* Gesamtbreite begrenzen */
body{
  max-width: 1100px;
  margin: 16px auto;
  padding: 0 14px;
}

/* Top-Row: links + Pfeile + rechts */
.top-area{
  display: grid;
  grid-template-columns: minmax(280px, 1fr) minmax(280px, 1fr);
  gap: 14px;
  align-items: center;
}

/* Kartenoptik */
.card{
  background: var(--card);
  border: 1px solid var(--soft);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding: 18px;          /* vorher 10px */
}

/* Tabellen kompakter */
table{
  width: 100%;
  table-layout: auto;      /* macht es natürlicher schmal */
  border-collapse: collapse;
  background: #fff;
}

th, td{
  border: 1px solid var(--border);
  padding: 8px 12px;     /* vorher 5px 8px */
  font-size: 18px;       /* vorher 13px */
  white-space: nowrap;
}


caption{
  font-weight: 700;
  margin-bottom: 10px;
  font-size: 20px;
}


/* Ergebnisbereich zentral und schmaler */
.result-wrap{
  margin-top: 16px;
}

.result-wrap .card{
  max-width: 1000px;
  margin: 0 auto;
}

.result-wrap table th,
.result-wrap table td{
  font-size: 19px;
}


/* Responsive: auf kleineren Screens untereinander */
@media (max-width: 920px){
  .top-area{
    grid-template-columns: 1fr;
  }
  .arrow-card{
    display:none; /* auf Handy/iPad im Portrait ausblenden (nicht nötig) */
  }
  body{
    max-width: 760px;
  }
}

    .topline{
      display:flex;
      gap:12px;
      align-items:baseline;
      flex-wrap:wrap;
      margin-bottom:12px;
    }
    .hint{
      color:#444;
      font-size:18px;     /* vorher 14px */
      line-height:1.4;
    }
    .scenario{
      font-weight:700;
      font-size:20px;
    }




    /* Selection highlight for source tables */
    tr.selected-left td { background: rgba(255, 45, 141, 0.18); }
    tr.selected-right td { background: rgba(110, 198, 255, 0.22); }

    tr.result-row:hover td{
      background:#f4f4f4;
    }
    tr.result-row.active td{
      outline:2px solid #000;
      outline-offset:-2px;
      background:#f0f0f0;
    }

    .error{
      border:1px solid #c00;
      padding:10px;
      margin:12px 0;
      background:#fff5f5;
      color:#900;
      font-size:14px;
    }

    th, td{
      max-width: 160px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .arrow-row{
  display:flex;
  justify-content:center;
  margin: 6px 0 10px;
}

.arrow-join{
  width: 330px;    /* vorher 220px */
  height: 105px;   /* vorher 70px */
}

tbody tr{ cursor: pointer; }
tbody tr:active td{ transform: scale(0.999); }

/* Quelle: Zeile wurde schon benutzt (bleibt klickbar) */
tr.used td{
  background: #f2f2f2;
  color: #666;
}

/* Wenn eine benutzte Zeile gerade ausgewählt wird, soll sie trotzdem klar leuchten */
tr.used.selected-left td { background: rgba(255, 45, 141, 0.18); color:#000; }
tr.used.selected-right td { background: rgba(110, 198, 255, 0.22); color:#000; }

/* Visuelle Trennung zwischen linker und rechter JOIN-Hälfte */
th.split-left,
td.split-left{
  border-left: 4px solid #000 !important;
}


  </style>
</head>
<body>
  <div class="topline">
    
    <div class="hint">
    </div>
  </div>

  <div id="err" class="error" style="display:none"></div>

 <div class="top-area">
  <div class="card">
    <table id="leftTable"></table>
  </div>

    <div class="card">
    <table id="rightTable"></table>
  </div>
</div>

<div class="arrow-row" aria-hidden="true">
  <svg class="arrow-join" viewBox="0 0 520 140" xmlns="http://www.w3.org/2000/svg">
    <!-- Links (pink) -->
    <path d="M30 30 C180 30 210 30 260 95"
          fill="none" stroke="#ff2d8d" stroke-width="18" stroke-linecap="round"/>
    <path d="M260 95 L235 85 L252 70 Z" fill="#ff2d8d"/>

    <!-- Rechts (blau) -->
    <path d="M490 30 C340 30 310 30 260 95"
          fill="none" stroke="#6ec6ff" stroke-width="18" stroke-linecap="round"/>
    <path d="M260 95 L268 70 L285 85 Z" fill="#6ec6ff"/>
  </svg>
</div>



<div class="result-wrap">
  <div class="card">
    <table id="resultTable"></table>
  </div>
</div>


<script>
(() => {
  // ----------------------------
  // Helpers: URL + CSV parsing
  // ----------------------------
  const qs = new URLSearchParams(location.search);
  const scenario = Number(qs.get("s") || "1");
  document.getElementById("scenarioNum").textContent = String(scenario);

  const fileL = `${scenario}_l.csv`;
  const fileR = `${scenario}_r.csv`;

  const errBox = document.getElementById("err");
  function showError(msg){
    errBox.style.display = "block";
    errBox.textContent = msg;
  }

  function detectDelimiter(line){
    const candidates = [";", ",", "\t"];
    let best = {delim:";", count:-1};
    for(const d of candidates){
      const c = (line.match(new RegExp(escapeRegExp(d), "g")) || []).length;
      if(c > best.count) best = {delim:d, count:c};
    }
    return best.delim;
  }
  function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

  function parseCSV(text){
    // minimaler CSV-Parser (ohne komplexe quoted-commas-Fälle).
    // Für Schul-CSV reicht das i.d.R. Wenn du Quotes brauchst, sagen.
    const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l => l.trim().length>0);
    if(lines.length === 0) return {headers:[], rows:[]};
    const delim = detectDelimiter(lines[0]);

    const headers = lines[0].split(delim).map(h => h.trim());
    const rows = [];
    for(let i=1;i<lines.length;i++){
      const parts = lines[i].split(delim);
      const row = {};
      headers.forEach((h, idx) => row[h] = (parts[idx] ?? "").trim());
      rows.push(row);
    }
    return {headers, rows};
  }

  async function loadCSV(path){
    const res = await fetch(path, {cache:"no-store"});
    if(!res.ok) throw new Error(`Konnte ${path} nicht laden (HTTP ${res.status}). Liegt die Datei im selben Ordner wie index.html?`);
    const txt = await res.text();
    return parseCSV(txt);
  }

  // ----------------------------
  // Rendering
  // ----------------------------
  function renderTable(el, captionText, headers, rows, onRowClick){
    el.innerHTML = "";
    const cap = document.createElement("caption");
    cap.textContent = captionText;
    el.appendChild(cap);

    const thead = document.createElement("thead");
    const trh = document.createElement("tr");
    headers.forEach(h => {
      const th = document.createElement("th");
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    el.appendChild(thead);

    const tbody = document.createElement("tbody");
    rows.forEach((r, idx) => {
      const tr = document.createElement("tr");
      // used-Markierung
      if (el.id === "leftTable" && usedLeft.has(idx)) tr.classList.add("used");
      if (el.id === "rightTable" && usedRight.has(idx)) tr.classList.add("used");

      tr.dataset.index = String(idx);
      headers.forEach(h => {
        const td = document.createElement("td");
        td.textContent = r[h] ?? "";
        tr.appendChild(td);
      });
      tr.addEventListener("click", (e) => {
        e.preventDefault();
        onRowClick(idx, tr);
      }, {passive:false});
      tbody.appendChild(tr);
    });
    el.appendChild(tbody);
  }

  // ----------------------------
  // State
  // ----------------------------
  let left = null;   // {headers, rows}
  let right = null;  // {headers, rows}
  let leftIdCol = null;
  let rightIdCol = null;
  let leftMap = null;
  let rightMap = null;
  let leftColumnCount = 0;




  let selected = null; // { side: "L"|"R", idx: number } oder null
  let usedLeft = new Set();
  let usedRight = new Set();


  // Result schema = leftHeaders + rightHeaders
  // Result data stored as array of objects with those keys
  let resultHeaders = [];
  let resultRows = [];

  const leftTable = document.getElementById("leftTable");
  const rightTable = document.getElementById("rightTable");
  const resultTable = document.getElementById("resultTable");

  function clearSelection(tableEl, cls){
    tableEl.querySelectorAll("tbody tr." + cls).forEach(tr => tr.classList.remove(cls));
  }

  function clearAllSelections(){
  clearSelection(leftTable, "selected-left");
  clearSelection(rightTable, "selected-right");
  }

  function setLeftSelection(idx, tr){
    selected = { side: "L", idx };
    clearAllSelections();
    tr.classList.add("selected-left");
  }

  function setRightSelection(idx, tr){
    selected = { side: "R", idx };
    clearAllSelections();
    tr.classList.add("selected-right");
  }


  function makeEmptyResultRow(){
    const obj = {};
    for(const h of resultHeaders) obj[h] = "";
    return obj;
  }

  function ensureOneEmptyRowAtEnd(){
    // Wenn letzte Zeile irgendeinen Wert enthält -> neue leere Zeile anhängen
    if(resultRows.length === 0){
      resultRows.push(makeEmptyResultRow());
      return;
    }
    const last = resultRows[resultRows.length - 1];
    const hasAny = resultHeaders.some(h => (last[h] ?? "") !== "");
    if(hasAny) resultRows.push(makeEmptyResultRow());
  }

  function refreshAll(){
  ensureOneEmptyRowAtEnd();
  recomputeUsedFromResult();

  renderTable(leftTable, `philosophieKlasse9`, left.headers, left.rows, setLeftSelection);
  renderTable(rightTable, `allergien`, right.headers, right.rows, setRightSelection);
  renderResult();
}

function displayHeader(h){
  if(h.startsWith("L_")) return h.slice(2);
  if(h.startsWith("R_")) return h.slice(2);
  return h;
}



  function renderResult(){
    resultTable.innerHTML = "";
    const cap = document.createElement("caption");
    cap.textContent = "Ergebnis";
    resultTable.appendChild(cap);

    const thead = document.createElement("thead");
    const trh = document.createElement("tr");
    resultHeaders.forEach((h, idx) => {
      const th = document.createElement("th");
      th.textContent = displayHeader(h);

      // Trennlinie vor erster rechter Spalte
      if(idx === leftColumnCount){
        th.classList.add("split-left");
      }

      trh.appendChild(th);
    });


    thead.appendChild(trh);
    resultTable.appendChild(thead);

    const tbody = document.createElement("tbody");
    resultRows.forEach((r, idx) => {
      const tr = document.createElement("tr");
      tr.classList.add("result-row");
      tr.dataset.index = String(idx);

      resultHeaders.forEach((h, colIdx) => {
        const td = document.createElement("td");
        const v = (r[h] ?? "").trim();
        const isLastRow = (idx === resultRows.length - 1);
        td.textContent = (v === "" && !isLastRow) ? "NULL" : v;

        // Trennlinie vor erster rechter Spalte
        if(colIdx === leftColumnCount){
          td.classList.add("split-left");
        }

        tr.appendChild(td);
      });


      tr.addEventListener("click", (e) => {
        e.preventDefault();
        // mark active row briefly
        resultTable.querySelectorAll("tbody tr.active").forEach(x => x.classList.remove("active"));

        if(!selected){
          const isLastRow = (idx === resultRows.length - 1);
          if(!isLastRow){
            resultRows.splice(idx, 1);
          }
          refreshAll();
          return;
        }


        // Paste selected left/right into this result row
        const rowObj = resultRows[idx];

       if(selected.side === "L"){
          const src = left.rows[selected.idx];
          left.headers.forEach(h => rowObj[leftMap[h]] = src[h] ?? "");
        } else if(selected.side === "R"){
          const src = right.rows[selected.idx];
          right.headers.forEach(h => rowObj[rightMap[h]] = src[h] ?? "");
        }


        // Nach dem Einfügen: Auswahl aufheben
        selected = null;
        refreshAll();

      }, {passive:false});

      tbody.appendChild(tr);
    });
    resultTable.appendChild(tbody);
  }

function recomputeUsedFromResult(){
  const usedLeftIds = new Set();
  const usedRightIds = new Set();

  // letzte Eingabezeile ignorieren
  const upto = Math.max(0, resultRows.length - 1);
  for(let i = 0; i < upto; i++){
    const row = resultRows[i];

    const lId = (row[leftMap[leftIdCol]] ?? "").trim();
    const rId = (row[rightMap[rightIdCol]] ?? "").trim();


    if(lId !== "" && lId !== "NULL") usedLeftIds.add(lId);
    if(rId !== "" && rId !== "NULL") usedRightIds.add(rId);
  }

  usedLeft = new Set();
  usedRight = new Set();

  left.rows.forEach((r, idx) => {
    const id = (r[leftIdCol] ?? "").trim();
    if(usedLeftIds.has(id)) usedLeft.add(idx);
  });

  right.rows.forEach((r, idx) => {
    const id = (r[rightIdCol] ?? "").trim();
    if(usedRightIds.has(id)) usedRight.add(idx);
  });
}



  // ----------------------------
  // Init
  // ----------------------------
  (async () => {
    try{
      [left, right] = await Promise.all([loadCSV(fileL), loadCSV(fileR)]);

      leftMap = Object.fromEntries(left.headers.map(h => [h, `L_${h}`]));
      rightMap = Object.fromEntries(right.headers.map(h => [h, `R_${h}`]));

      resultHeaders = [
        ...left.headers.map(h => leftMap[h]),
        ...right.headers.map(h => rightMap[h])
      ];

      leftColumnCount = left.headers.length;

      // Render source tables
      renderTable(leftTable, `philosophieKlasse9`, left.headers, left.rows, setLeftSelection);
      renderTable(rightTable, `allergien`, right.headers, right.rows, setRightSelection);


      leftIdCol = left.headers.find(h => /_id$/i.test(h)) ?? left.headers[0];
      rightIdCol = right.headers.find(h => /_id$/i.test(h)) ?? right.headers[0];



      // start with one empty row
      resultRows = [makeEmptyResultRow()];
      recomputeUsedFromResult();
      renderResult();


    } catch(err){
      showError(String(err.message || err));
    }
  })();

  // Optional: einfache Wisch-Geste für Szenariowechsel (ohne Buttons)
  let touchStartX = null, touchStartY = null;
  window.addEventListener("touchstart", (e) => {
    if(!e.touches || e.touches.length !== 1) return;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  }, {passive:true});

  window.addEventListener("touchend", (e) => {
    if(touchStartX === null || touchStartY === null) return;
    const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
    if(!t) return;
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    touchStartX = touchStartY = null;
    // horizontal swipe only
    if(Math.abs(dx) > 80 && Math.abs(dy) < 60){
      const next = scenario + (dx < 0 ? 1 : -1);
      if(next >= 1){
        const url = new URL(location.href);
        url.searchParams.set("s", String(next));
        location.href = url.toString();
      }
    }
  }, {passive:true});
})();
</script>
</body>
</html>
